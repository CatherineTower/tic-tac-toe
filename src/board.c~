#include <stdlib.h>
#include <assert.h>
#include <string.h>

#include "board.h"

static inline int boardCoordinate(GameBoard const *board, int x, int y);

int GameBoardInit(GameBoard *board, int dimension) {
  assert(dimension > 0);

  board->dimension = dimension;

  board->spaces = malloc(sizeof(int) * dimension * dimension);
  assert(board->spaces != NULL);
  memset(board->spaces, SPACE_FREE, sizeof(int) * dimension * dimension);

  return 0;
}

void GameBoardDestroy(GameBoard *board) {
  if(board != NULL) {
    free(board->spaces);
  }
}

void setSpace(GameBoard *board, int x, int y, SpaceDesignation designation) {
  board->spaces[boardCoordinate(board, x, y)] = designation;
}

SpaceDesignation getSpace(GameBoard const *board, int x, int y) {
  return board->spaces[boardCoordinate(board, x, y)];
}

static inline int boardCoordinate(GameBoard const *board, int x, int y) {
  assert(board != NULL && board->spaces != NULL);
  assert(x <= board->dimension && y <= board->dimension);

  return (y * board->dimension) + x;
}

SpaceDesignation testWin(GameBoard const *board) {
  /* test rows */
  for(int y = 0; y < board->dimension; y++) {
    /* spacesCount[0] is the number of spaces the player's got for a
     particular run. spacesCount[1] is the number of spaces the CPU's
     got. */
  int spacesCount[2] = {};
    for(int x = 0; x < board->dimension; x++) {
      switch(board->spaces[boardCoordinate(board, x, y)]) {
      default:
        continue;
      case SPACE_PLAYER:
        spacesCount[0]++;
        break;
      case SPACE_CPU:
        spacesCount[1]++;
        break;
      }
    }
    if(spacesCount[0] == board->dimension) {
      return SPACE_PLAYER;
    }
    if(spacesCount[1] == board->dimension) {
      return SPACE_CPU;
    }
  }

  /* Test columns */
  for(int x = 0; x < board->dimension; x++) {
    int spacesCount[2] = {};
    for(int y = 0; y < board->dimension; y++) {
      switch(board->spaces[boardCoordinate(board, x, y)]) {
      default:
        continue;
      case SPACE_PLAYER:
        spacesCount[0]++;
        break;
      case SPACE_CPU:
        spacesCount[1]++;
        break;
      }
    }
    if(spacesCount[0] == board->dimension) {
      return SPACE_PLAYER;
    }
    if(spacesCount[1] == board->dimension) {
      return SPACE_CPU;
    }
  }

  /* Test diagonals */
  int spacesCount[2] = {};
  for(int i = 0; i < board->dimension; i++) {
    switch(board->spaces[boardCoordinate(board, i, i)]) {
    default:
      continue;
    case SPACE_PLAYER:
      spacesCount[0]++;
      break;
    case SPACE_CPU:
      spacesCount[1]++;
      break;
    }
  }
  if(spacesCount[0] == board->dimension) {
    return SPACE_PLAYER;
  }
  if(spacesCount[1] == board->dimension) {
    return SPACE_CPU;
  }

  spacesCount[0] = 0;
  spacesCount[1] = 0;
  for(int i = 0; i < board->dimension; i++) {
    switch(board->spaces[boardCoordinate(board, board->dimension - i, board->dimension - i)]) {
    default:
      continue;
    case SPACE_PLAYER:
      spacesCount[0]++;
      break;
    case SPACE_CPU:
      spacesCount[1]++;
      break;
    }
  }
  if(spacesCount[0] == board->dimension) {
    return SPACE_PLAYER;
  }
  if(spacesCount[1] == board->dimension) {
    return SPACE_CPU;
  }
  return SPACE_FREE;
}

#ifdef UNITTEST
int main(void) {
  GameBoard test;
  GameBoardInit(&test, 3);
  assert(test.dimension == 3);
  assert(testWin(&test) == SPACE_FREE);

  setSpace(&test, 0, 0, SPACE_PLAYER);
  setSpace(&test, 1, 1, SPACE_CPU);
  setSpace(&test, 2, 2, SPACE_PLAYER);
  assert(testWin(&test) == SPACE_FREE);

  assert(boardCoordinate(&test, 1, 1) == 4);
  assert(boardCoordinate(&test, 2, 2) == 8);

  assert(test.spaces[0] == SPACE_PLAYER);
  assert(test.spaces[4] == SPACE_CPU);
  assert(test.spaces[8] == SPACE_PLAYER);

  setSpace(&test, 0, 0, SPACE_PLAYER);
  setSpace(&test, 1, 0, SPACE_PLAYER);
  setSpace(&test, 2, 0, SPACE_PLAYER);
  assert(testWin(&test) == SPACE_PLAYER);

  GameBoardDestroy(&test);

  GameBoardInit(&test, 4);
  setSpace(&test, 0, 0, SPACE_CPU);
  setSpace(&test, 1, 0, SPACE_CPU);
  setSpace(&test, 2, 0, SPACE_CPU);
  setSpace(&test, 3, 0, SPACE_CPU);
  assert(testWin(&test) == SPACE_CPU);

  return 0;
}
#endif  /* UNITTEST */
